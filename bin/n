#!/usr/bin/env python3
"""n - CLI memo/note TUI (2-pane, Neo-tree + editor style)"""

import curses
import json
import os
import subprocess
import unicodedata
from datetime import datetime

NOTES_FILE = os.path.expanduser("~/.notes.json")
TEMPLATES_FILE = os.path.expanduser("~/.note-templates.json")

# Nerd Font icons
ICON_NOTE = "\uf15c"
ICON_CURSOR = "\uf054"
ICON_TMPL = "\uf0c5"


def char_width(ch):
    """Return display width of a single character."""
    ea = unicodedata.east_asian_width(ch)
    return 2 if ea in ("F", "W") else 1


def str_width(s):
    """Return display width of a string."""
    return sum(char_width(c) for c in s)


def truncate_to_width(s, max_w):
    """Truncate string to fit within max_w display columns."""
    w = 0
    for i, c in enumerate(s):
        cw = char_width(c)
        if w + cw > max_w:
            return s[:i]
        w += cw
    return s


def safe_addstr(win, y, x, text, max_w, attr=0):
    """Add string to window, properly truncated for display width."""
    truncated = truncate_to_width(text, max_w)
    try:
        win.addstr(y, x, truncated, attr)
    except curses.error:
        pass


def load_json(path):
    if os.path.exists(path):
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    return []


def save_json(path, data):
    with open(path, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)


def load_notes():
    return load_json(NOTES_FILE)


def save_notes(notes):
    save_json(NOTES_FILE, notes)


def load_templates():
    return load_json(TEMPLATES_FILE)


def save_templates(templates):
    save_json(TEMPLATES_FILE, templates)


def next_id(items):
    return max((t["id"] for t in items), default=0) + 1


def now_str():
    return datetime.now().strftime("%Y-%m-%dT%H:%M:%S")


def format_date(dt_str):
    """Format datetime string for display."""
    try:
        dt = datetime.fromisoformat(dt_str)
        return dt.strftime("%m/%d %H:%M")
    except (ValueError, TypeError):
        return ""


def copy_to_clipboard(text):
    """Copy text to system clipboard via pbcopy."""
    try:
        proc = subprocess.Popen(["pbcopy"], stdin=subprocess.PIPE)
        proc.communicate(text.encode("utf-8"))
    except FileNotFoundError:
        pass


def sort_notes(notes):
    """Sort notes by updated descending."""
    notes.sort(key=lambda n: n.get("updated", ""), reverse=True)


def textbox_input(stdscr, y, x, width, prompt="", initial=""):
    """Text input on curses screen."""
    curses.curs_set(1)
    h, w = stdscr.getmaxyx()
    prompt_w = str_width(prompt)
    safe_addstr(stdscr, y, x, prompt, w - x)
    input_x = x + prompt_w
    max_cols = min(width - prompt_w - 1, w - input_x - 1)

    buf = list(initial)
    pos = len(buf)
    scroll = 0

    while True:
        visible = ""
        vis_w = 0
        cursor_col = 0

        for i in range(scroll, len(buf)):
            cw = char_width(buf[i])
            if vis_w + cw > max_cols:
                break
            visible += buf[i]
            vis_w += cw
            if i < pos:
                cursor_col += cw

        if pos == scroll:
            cursor_col = 0
        if pos < scroll:
            scroll = pos
            continue
        if cursor_col >= max_cols:
            scroll += 1
            continue

        pad = " " * max(0, max_cols - vis_w)
        try:
            stdscr.addstr(y, input_x, visible + pad)
            stdscr.move(y, input_x + cursor_col)
        except curses.error:
            pass
        stdscr.refresh()

        ch = stdscr.get_wch()

        if ch == "\n" or ch == curses.KEY_ENTER:
            break
        elif ch == "\x1b":
            curses.curs_set(0)
            return None
        elif ch in ("\x7f", "\b", curses.KEY_BACKSPACE):
            if pos > 0:
                buf.pop(pos - 1)
                pos -= 1
                if scroll > 0:
                    scroll = max(0, scroll - 1)
        elif ch == curses.KEY_DC:
            if pos < len(buf):
                buf.pop(pos)
        elif ch == curses.KEY_LEFT:
            if pos > 0:
                pos -= 1
        elif ch == curses.KEY_RIGHT:
            if pos < len(buf):
                pos += 1
        elif ch == curses.KEY_HOME or ch == "\x01":
            pos = 0
            scroll = 0
        elif ch == curses.KEY_END or ch == "\x05":
            pos = len(buf)
        elif ch == "\x15":  # Ctrl-U
            buf = buf[pos:]
            pos = 0
            scroll = 0
        elif ch == "\x0b":  # Ctrl-K
            buf = buf[:pos]
        elif isinstance(ch, str) and len(ch) == 1 and ch >= " ":
            buf.insert(pos, ch)
            pos += 1

    curses.curs_set(0)
    return "".join(buf)


def body_editor(stdscr, title, body_text, area_top, area_left, area_w, area_h):
    """In-pane body editor. Returns new body on save (Alt+Enter), None on cancel (ESC)."""
    curses.curs_set(1)

    lines = body_text.split("\n") if body_text else [""]
    cy, cx = 0, 0
    scroll = 0
    visible_lines = area_h

    while True:
        # Draw body area
        for i in range(visible_lines):
            li = scroll + i
            row = area_top + i
            try:
                stdscr.move(row, area_left)
                stdscr.clrtoeol()
            except curses.error:
                pass
            if li < len(lines):
                safe_addstr(stdscr, row, area_left, lines[li], area_w)

        # Update footer
        h, w = stdscr.getmaxyx()
        footer = " Alt+Enter:Save  ESC:Cancel"
        try:
            stdscr.move(h - 1, 0)
            stdscr.clrtoeol()
        except curses.error:
            pass
        safe_addstr(stdscr, h - 1, 0, footer, w - 1)

        # Scroll management
        if cy - scroll >= visible_lines:
            scroll = cy - visible_lines + 1
        if cy < scroll:
            scroll = cy

        # Position cursor
        screen_y = area_top + cy - scroll
        screen_x = area_left + str_width(lines[cy][:cx]) if cy < len(lines) else area_left
        screen_x = min(screen_x, area_left + area_w - 1)
        try:
            stdscr.move(screen_y, screen_x)
        except curses.error:
            pass
        stdscr.refresh()

        ch = stdscr.get_wch()

        if ch == "\x1b":
            stdscr.nodelay(True)
            next_ch = None
            try:
                next_ch = stdscr.get_wch()
            except curses.error:
                pass
            stdscr.nodelay(False)
            if next_ch == "\n" or next_ch == "\r":
                curses.curs_set(0)
                return "\n".join(lines)
            else:
                curses.curs_set(0)
                return None
        elif ch == "\n" or ch == curses.KEY_ENTER:
            rest = lines[cy][cx:]
            lines[cy] = lines[cy][:cx]
            lines.insert(cy + 1, rest)
            cy += 1
            cx = 0
        elif ch in ("\x7f", "\b", curses.KEY_BACKSPACE):
            if cx > 0:
                lines[cy] = lines[cy][:cx - 1] + lines[cy][cx:]
                cx -= 1
            elif cy > 0:
                cx = len(lines[cy - 1])
                lines[cy - 1] += lines[cy]
                lines.pop(cy)
                cy -= 1
        elif ch == curses.KEY_DC:
            if cx < len(lines[cy]):
                lines[cy] = lines[cy][:cx] + lines[cy][cx + 1:]
            elif cy < len(lines) - 1:
                lines[cy] += lines[cy + 1]
                lines.pop(cy + 1)
        elif ch == curses.KEY_UP:
            if cy > 0:
                cy -= 1
                cx = min(cx, len(lines[cy]))
        elif ch == curses.KEY_DOWN:
            if cy < len(lines) - 1:
                cy += 1
                cx = min(cx, len(lines[cy]))
        elif ch == curses.KEY_LEFT:
            if cx > 0:
                cx -= 1
            elif cy > 0:
                cy -= 1
                cx = len(lines[cy])
        elif ch == curses.KEY_RIGHT:
            if cx < len(lines[cy]):
                cx += 1
            elif cy < len(lines) - 1:
                cy += 1
                cx = 0
        elif ch == curses.KEY_HOME or ch == "\x01":
            cx = 0
        elif ch == curses.KEY_END or ch == "\x05":
            cx = len(lines[cy])
        elif isinstance(ch, str) and len(ch) == 1 and ch >= " ":
            lines[cy] = lines[cy][:cx] + ch + lines[cy][cx:]
            cx += 1


def template_editor(stdscr, title, body_text):
    """Fullscreen body editor for templates."""
    curses.curs_set(1)
    h, w = stdscr.getmaxyx()

    lines = body_text.split("\n") if body_text else [""]
    cy, cx = 0, 0
    scroll = 0

    while True:
        stdscr.erase()
        header = f" {ICON_TMPL} Template: {title} "
        stdscr.attron(curses.A_BOLD)
        safe_addstr(stdscr, 0, 0, header, w - 1)
        stdscr.attroff(curses.A_BOLD)
        safe_addstr(stdscr, 1, 0, "─" * (w - 1), w - 1)

        edit_top = 2
        visible_lines = h - edit_top - 2

        if cy - scroll >= visible_lines:
            scroll = cy - visible_lines + 1
        if cy < scroll:
            scroll = cy

        for i in range(visible_lines):
            li = scroll + i
            row = edit_top + i
            if li < len(lines):
                safe_addstr(stdscr, row, 0, lines[li], w - 1)

        footer = " Alt+Enter:Save  ESC:Cancel "
        safe_addstr(stdscr, h - 1, 0, footer, w - 1, curses.A_REVERSE)

        screen_y = edit_top + cy - scroll
        screen_x = str_width(lines[cy][:cx]) if cy < len(lines) else 0
        screen_x = min(screen_x, w - 1)
        try:
            stdscr.move(screen_y, screen_x)
        except curses.error:
            pass
        stdscr.refresh()

        ch = stdscr.get_wch()

        if ch == "\x1b":
            stdscr.nodelay(True)
            next_ch = None
            try:
                next_ch = stdscr.get_wch()
            except curses.error:
                pass
            stdscr.nodelay(False)
            if next_ch == "\n" or next_ch == "\r":
                curses.curs_set(0)
                return "\n".join(lines)
            else:
                curses.curs_set(0)
                return None
        elif ch == "\n" or ch == curses.KEY_ENTER:
            rest = lines[cy][cx:]
            lines[cy] = lines[cy][:cx]
            lines.insert(cy + 1, rest)
            cy += 1
            cx = 0
        elif ch in ("\x7f", "\b", curses.KEY_BACKSPACE):
            if cx > 0:
                lines[cy] = lines[cy][:cx - 1] + lines[cy][cx:]
                cx -= 1
            elif cy > 0:
                cx = len(lines[cy - 1])
                lines[cy - 1] += lines[cy]
                lines.pop(cy)
                cy -= 1
        elif ch == curses.KEY_DC:
            if cx < len(lines[cy]):
                lines[cy] = lines[cy][:cx] + lines[cy][cx + 1:]
            elif cy < len(lines) - 1:
                lines[cy] += lines[cy + 1]
                lines.pop(cy + 1)
        elif ch == curses.KEY_UP:
            if cy > 0:
                cy -= 1
                cx = min(cx, len(lines[cy]))
        elif ch == curses.KEY_DOWN:
            if cy < len(lines) - 1:
                cy += 1
                cx = min(cx, len(lines[cy]))
        elif ch == curses.KEY_LEFT:
            if cx > 0:
                cx -= 1
            elif cy > 0:
                cy -= 1
                cx = len(lines[cy])
        elif ch == curses.KEY_RIGHT:
            if cx < len(lines[cy]):
                cx += 1
            elif cy < len(lines) - 1:
                cy += 1
                cx = 0
        elif ch == curses.KEY_HOME or ch == "\x01":
            cx = 0
        elif ch == curses.KEY_END or ch == "\x05":
            cx = len(lines[cy])
        elif isinstance(ch, str) and len(ch) == 1 and ch >= " ":
            lines[cy] = lines[cy][:cx] + ch + lines[cy][cx:]
            cx += 1


def template_manager(stdscr):
    """Template management screen."""
    templates = load_templates()
    cursor = 0
    message = ""

    while True:
        stdscr.erase()
        h, w = stdscr.getmaxyx()

        header = f" {ICON_TMPL} Templates ({len(templates)})"
        stdscr.attron(curses.A_BOLD)
        safe_addstr(stdscr, 0, 0, header, w - 1)
        stdscr.attroff(curses.A_BOLD)

        sep = "─" * (w - 1)
        safe_addstr(stdscr, 1, 0, sep, w - 1)

        row = 2
        for i, tmpl in enumerate(templates):
            if row >= h - 2:
                break
            prefix = f" {ICON_CURSOR} " if i == cursor else "   "
            line = f"{prefix}{i + 1}.  {tmpl['title']}"
            attr = curses.A_REVERSE if i == cursor else 0
            pad_needed = w - 1 - str_width(line)
            if pad_needed > 0:
                line += " " * pad_needed
            safe_addstr(stdscr, row, 0, line, w - 1, attr)
            row += 1

        if h - 2 >= 0:
            safe_addstr(stdscr, h - 2, 0, sep, w - 1)

        if message:
            footer = f" {message}"
        else:
            footer = " a:Add  x:Del  e:Edit  ESC:Back"
        safe_addstr(stdscr, h - 1, 0, footer, w - 1)

        stdscr.refresh()
        message = ""

        ch = stdscr.getch()

        if ch == 27:  # ESC
            return
        elif ch == ord("j") or ch == curses.KEY_DOWN:
            if templates and cursor < len(templates) - 1:
                cursor += 1
        elif ch == ord("k") or ch == curses.KEY_UP:
            if cursor > 0:
                cursor -= 1
        elif ch == ord("g"):
            cursor = 0
        elif ch == ord("G"):
            if templates:
                cursor = len(templates) - 1
        elif ch == ord("a"):
            title = textbox_input(stdscr, h - 1, 0, w, " Template name: ")
            if title and title.strip():
                body = template_editor(stdscr, title.strip(), "")
                if body is not None:
                    templates.append({
                        "id": next_id(templates),
                        "title": title.strip(),
                        "body": body,
                    })
                    save_templates(templates)
                    cursor = len(templates) - 1
                    message = "Template added"
        elif ch == ord("x"):
            if templates:
                name = templates[cursor]["title"]
                prompt = f" Delete '{name}'? (y/n) "
                pad = " " * max(0, w - 1 - str_width(prompt))
                safe_addstr(stdscr, h - 1, 0, prompt + pad, w - 1, curses.A_REVERSE)
                stdscr.refresh()
                confirm = stdscr.getch()
                if confirm == ord("y"):
                    templates.pop(cursor)
                    if cursor >= len(templates) and cursor > 0:
                        cursor -= 1
                    save_templates(templates)
                    message = "Deleted"
                else:
                    message = "Cancelled"
        elif ch == ord("e") or ch == ord("\n") or ch == curses.KEY_ENTER:
            if templates:
                tmpl = templates[cursor]
                body = template_editor(stdscr, tmpl["title"], tmpl["body"])
                if body is not None:
                    tmpl["body"] = body
                    save_templates(templates)
                    message = "Template saved"


def draw_main(stdscr, notes, cursor, left_w, focus, message, editing):
    """Draw the 2-pane main screen."""
    h, w = stdscr.getmaxyx()
    stdscr.erase()

    right_x = left_w + 1
    right_w = w - right_x

    # --- Left pane header ---
    lh = f" {ICON_NOTE} Notes ({len(notes)})"
    stdscr.attron(curses.A_BOLD)
    safe_addstr(stdscr, 0, 0, lh, left_w)
    stdscr.attroff(curses.A_BOLD)

    # --- Right pane header ---
    if notes and 0 <= cursor < len(notes):
        note = notes[cursor]
        rh_title = note["title"]
        rh_date = format_date(note.get("updated", ""))
        rh_right = rh_date
        rh_left = f" {rh_title}"
        avail = right_w - str_width(rh_right) - 2
        rh_left = truncate_to_width(rh_left, avail)
        gap = right_w - str_width(rh_left) - str_width(rh_right)
        rh = rh_left + " " * max(1, gap) + rh_right
    else:
        rh = ""
    stdscr.attron(curses.A_BOLD)
    safe_addstr(stdscr, 0, right_x, rh, right_w)
    stdscr.attroff(curses.A_BOLD)

    # --- Separator line row 1 ---
    for col in range(left_w):
        safe_addstr(stdscr, 1, col, "─", 1)
    safe_addstr(stdscr, 1, left_w, "┼", 1)
    for col in range(right_x, w - 1):
        safe_addstr(stdscr, 1, col, "─", 1)

    # --- Vertical separator ---
    safe_addstr(stdscr, 0, left_w, "│", 1)
    for row in range(2, h - 2):
        safe_addstr(stdscr, row, left_w, "│", 1)

    # --- Left pane: note list ---
    list_top = 2
    list_h = h - 4
    for i, note in enumerate(notes):
        if i >= list_h:
            break
        row = list_top + i
        prefix = f" {ICON_CURSOR} " if i == cursor else "   "
        line = f"{prefix}{i + 1}.  {note['title']}"
        attr = 0
        if i == cursor:
            attr = curses.A_REVERSE if focus == "left" else curses.A_BOLD
        pad_needed = left_w - str_width(line)
        if pad_needed > 0:
            line += " " * pad_needed
        safe_addstr(stdscr, row, 0, line, left_w, attr)

    # --- Right pane: body preview ---
    if notes and 0 <= cursor < len(notes):
        body = notes[cursor].get("body", "")
        body_lines = body.split("\n") if body else [""]
        body_top = 2
        body_h = h - 4
        return body_lines, body_top, body_h, right_x, right_w
    else:
        return [], 2, h - 4, right_x, right_w


def main(stdscr):
    curses.curs_set(0)
    curses.use_default_colors()
    stdscr.keypad(True)

    notes = load_notes()
    sort_notes(notes)
    cursor = 0
    message = ""
    focus = "left"  # "left" or "right"
    right_scroll = 0

    while True:
        h, w = stdscr.getmaxyx()
        left_w = max(20, w * 30 // 100)

        body_lines, body_top, body_h, right_x, right_w = draw_main(
            stdscr, notes, cursor, left_w, focus, message, False
        )

        # Draw right pane body with scroll
        for i in range(body_h):
            li = right_scroll + i
            row = body_top + i
            if li < len(body_lines):
                safe_addstr(stdscr, row, right_x + 1, body_lines[li], right_w - 2)

        # Bottom separator
        sep = "─" * (w - 1)
        if h - 2 >= 0:
            safe_addstr(stdscr, h - 2, 0, sep, w - 1)

        # Footer
        if message:
            footer = f" {message}"
        else:
            if focus == "left":
                footer = " a:Add  x:Del  e:Rename  Enter:Edit  y:Copy  Tab:Switch  t:Tmpl  q:Quit"
            else:
                footer = " j/k:Scroll  g/G:Top/Bottom  y:Copy  Tab:Switch  q:Quit"
        safe_addstr(stdscr, h - 1, 0, footer, w - 1)

        # Focus indicator: highlight right pane border if right-focused
        if focus == "right":
            for row in range(2, h - 2):
                safe_addstr(stdscr, row, left_w, "│", 1, curses.A_BOLD)

        stdscr.refresh()
        message = ""

        ch = stdscr.getch()

        if ch == ord("q"):
            break
        elif ch == ord("\t") or ch == 9:  # Tab
            if focus == "left":
                focus = "right"
                right_scroll = 0
            else:
                focus = "left"
        elif focus == "left":
            if ch == ord("j") or ch == curses.KEY_DOWN:
                if notes and cursor < len(notes) - 1:
                    cursor += 1
                    right_scroll = 0
            elif ch == ord("k") or ch == curses.KEY_UP:
                if cursor > 0:
                    cursor -= 1
                    right_scroll = 0
            elif ch == ord("g"):
                cursor = 0
                right_scroll = 0
            elif ch == ord("G"):
                if notes:
                    cursor = len(notes) - 1
                    right_scroll = 0
            elif ch == ord("a"):
                # Template selection
                templates = load_templates()
                if templates:
                    prompt = " [1] Blank"
                    for i, tmpl in enumerate(templates):
                        prompt += f"  [{i + 2}] {tmpl['title']}"
                    prompt += "  "
                    safe_addstr(stdscr, h - 1, 0, " " * (w - 1), w - 1)
                    safe_addstr(stdscr, h - 1, 0, prompt, w - 1)
                    stdscr.refresh()
                    sel = stdscr.getch()
                    if sel == 27:  # ESC
                        continue
                    sel_idx = sel - ord("1") if ord("1") <= sel <= ord("9") else -1
                    if sel_idx == 0:
                        template_body = ""
                    elif 1 <= sel_idx <= len(templates):
                        template_body = templates[sel_idx - 1]["body"]
                    else:
                        continue
                else:
                    template_body = ""

                title = textbox_input(stdscr, h - 1, 0, w, " Title: ")
                if title and title.strip():
                    ts = now_str()
                    notes.append({
                        "id": next_id(notes),
                        "title": title.strip(),
                        "body": template_body,
                        "created": ts,
                        "updated": ts,
                    })
                    sort_notes(notes)
                    cursor = 0  # newest is at top after sort
                    save_notes(notes)
                    message = "Added"
            elif ch == ord("x"):
                if notes:
                    name = notes[cursor]["title"]
                    prompt = f" Delete '{name}'? (y/n) "
                    pad = " " * max(0, w - 1 - str_width(prompt))
                    safe_addstr(stdscr, h - 1, 0, prompt + pad, w - 1, curses.A_REVERSE)
                    stdscr.refresh()
                    confirm = stdscr.getch()
                    if confirm == ord("y"):
                        notes.pop(cursor)
                        if cursor >= len(notes) and cursor > 0:
                            cursor -= 1
                        save_notes(notes)
                        message = "Deleted"
                    else:
                        message = "Cancelled"
            elif ch == ord("e"):
                if notes:
                    old = notes[cursor]["title"]
                    new_title = textbox_input(stdscr, h - 1, 0, w, " Rename: ", old)
                    if new_title is not None and new_title.strip():
                        notes[cursor]["title"] = new_title.strip()
                        save_notes(notes)
                        message = "Renamed"
            elif ch == ord("\n") or ch == curses.KEY_ENTER:
                if notes:
                    note = notes[cursor]
                    # Redraw to enter edit mode
                    draw_main(stdscr, notes, cursor, left_w, "left", "", True)
                    # Draw separator + footer will be handled by editor
                    sep = "─" * (w - 1)
                    if h - 2 >= 0:
                        safe_addstr(stdscr, h - 2, 0, sep, w - 1)
                    # Vertical separator
                    for row in range(2, h - 2):
                        safe_addstr(stdscr, row, left_w, "│", 1)
                    stdscr.refresh()

                    area_top = 2
                    area_h = h - 4
                    result = body_editor(
                        stdscr, note["title"], note.get("body", ""),
                        area_top, right_x + 1, right_w - 2, area_h
                    )
                    if result is not None:
                        note["body"] = result
                        note["updated"] = now_str()
                        sort_notes(notes)
                        # Find cursor position after sort
                        for i, n in enumerate(notes):
                            if n["id"] == note["id"]:
                                cursor = i
                                break
                        save_notes(notes)
                        message = "Saved"
                    right_scroll = 0
            elif ch == ord("y"):
                if notes:
                    copy_to_clipboard(notes[cursor].get("body", ""))
                    message = "Copied to clipboard"
            elif ch == ord("t"):
                template_manager(stdscr)
        elif focus == "right":
            if ch == ord("j") or ch == curses.KEY_DOWN:
                if right_scroll < max(0, len(body_lines) - body_h):
                    right_scroll += 1
            elif ch == ord("k") or ch == curses.KEY_UP:
                if right_scroll > 0:
                    right_scroll -= 1
            elif ch == ord("g"):
                right_scroll = 0
            elif ch == ord("G"):
                right_scroll = max(0, len(body_lines) - body_h)
            elif ch == ord("y"):
                if notes:
                    copy_to_clipboard(notes[cursor].get("body", ""))
                    message = "Copied to clipboard"


if __name__ == "__main__":
    curses.wrapper(main)
