#!/usr/bin/env python3
"""n - CLI memo/note TUI (2-pane, Neo-tree + editor style)"""

import curses
import os
import re
import subprocess
import unicodedata
from datetime import datetime

NOTES_DIR = os.path.expanduser("~/.notes/notes")
TEMPLATES_DIR = os.path.expanduser("~/.notes/templates")

# Nerd Font icons
ICON_NOTE = "\uf15c"
ICON_CURSOR = "\uf054"
ICON_TMPL = "\uf0c5"


# ── Display utilities ──────────────────────────────────────────


def char_width(ch):
    cp = ord(ch)
    if 0xE000 <= cp <= 0xF8FF or 0xF0000 <= cp <= 0xFFFFD or 0x100000 <= cp <= 0x10FFFD:
        return 2
    ea = unicodedata.east_asian_width(ch)
    return 2 if ea in ("F", "W") else 1


def str_width(s):
    return sum(char_width(c) for c in s)


def truncate_to_width(s, max_w):
    w = 0
    for i, c in enumerate(s):
        cw = char_width(c)
        if w + cw > max_w:
            return s[:i]
        w += cw
    return s


def safe_addstr(win, y, x, text, max_w, attr=0):
    truncated = truncate_to_width(text, max_w)
    try:
        win.addstr(y, x, truncated, attr)
    except curses.error:
        pass


# ── Markdown note storage ──────────────────────────────────────


def sanitize_filename(title):
    """Convert title to a safe filename component."""
    s = re.sub(r'[\\/:*?"<>|]', "-", title)
    s = s.strip().strip(".")
    return s[:80] if s else "untitled"


def md_path(directory, item_id, title):
    return os.path.join(directory, f"{item_id}_{sanitize_filename(title)}.md")


def parse_frontmatter(text):
    """Parse YAML frontmatter from markdown text. Returns (meta_dict, body)."""
    if not text.startswith("---"):
        return {}, text
    end = text.find("\n---\n", 3)
    if end == -1:
        return {}, text
    fm_block = text[4:end]
    body = text[end + 5:]
    meta = {}
    for line in fm_block.split("\n"):
        if ": " in line:
            k, v = line.split(": ", 1)
            meta[k.strip()] = v.strip()
    return meta, body


def build_frontmatter(meta, keys=("id", "title", "created", "updated")):
    lines = ["---"]
    for k in keys:
        if k in meta:
            lines.append(f"{k}: {meta[k]}")
    lines.append("---")
    return "\n".join(lines)


def load_notes():
    """Load all notes from ~/.notes/ directory."""
    os.makedirs(NOTES_DIR, exist_ok=True)
    notes = []
    for fname in os.listdir(NOTES_DIR):
        if not fname.endswith(".md"):
            continue
        fpath = os.path.join(NOTES_DIR, fname)
        with open(fpath, "r", encoding="utf-8") as f:
            text = f.read()
        meta, body = parse_frontmatter(text)
        if "id" not in meta:
            continue
        notes.append({
            "id": int(meta["id"]),
            "title": meta.get("title", "untitled"),
            "body": body,
            "created": meta.get("created", ""),
            "updated": meta.get("updated", ""),
            "_path": fpath,
        })
    return notes


def save_note(note):
    """Save a single note as a markdown file."""
    os.makedirs(NOTES_DIR, exist_ok=True)
    old_path = note.get("_path")
    new_path = md_path(NOTES_DIR, note["id"], note["title"])
    if old_path and old_path != new_path and os.path.exists(old_path):
        os.remove(old_path)
    note["_path"] = new_path
    meta = {
        "id": str(note["id"]),
        "title": note["title"],
        "created": note["created"],
        "updated": note["updated"],
    }
    content = build_frontmatter(meta) + "\n" + note.get("body", "")
    with open(new_path, "w", encoding="utf-8") as f:
        f.write(content)


def delete_note(note):
    """Delete a note's markdown file."""
    path = note.get("_path")
    if path and os.path.exists(path):
        os.remove(path)


# ── Markdown template storage ──────────────────────────────────


def load_templates():
    """Load all templates from ~/.note-templates/ directory."""
    os.makedirs(TEMPLATES_DIR, exist_ok=True)
    templates = []
    for fname in os.listdir(TEMPLATES_DIR):
        if not fname.endswith(".md"):
            continue
        fpath = os.path.join(TEMPLATES_DIR, fname)
        with open(fpath, "r", encoding="utf-8") as f:
            text = f.read()
        meta, body = parse_frontmatter(text)
        if "id" not in meta:
            continue
        templates.append({
            "id": int(meta["id"]),
            "title": meta.get("title", "untitled"),
            "body": body,
            "_path": fpath,
        })
    templates.sort(key=lambda t: t["id"])
    return templates


def save_template(tmpl):
    """Save a single template as a markdown file."""
    os.makedirs(TEMPLATES_DIR, exist_ok=True)
    old_path = tmpl.get("_path")
    new_path = md_path(TEMPLATES_DIR, tmpl["id"], tmpl["title"])
    if old_path and old_path != new_path and os.path.exists(old_path):
        os.remove(old_path)
    tmpl["_path"] = new_path
    meta = {"id": str(tmpl["id"]), "title": tmpl["title"]}
    content = build_frontmatter(meta, keys=("id", "title")) + "\n" + tmpl.get("body", "")
    with open(new_path, "w", encoding="utf-8") as f:
        f.write(content)


def delete_template(tmpl):
    """Delete a template's markdown file."""
    path = tmpl.get("_path")
    if path and os.path.exists(path):
        os.remove(path)



# ── Utility ────────────────────────────────────────────────────


def next_id(items):
    return max((t["id"] for t in items), default=0) + 1


def now_str():
    return datetime.now().strftime("%Y-%m-%dT%H:%M:%S")


def format_date(dt_str):
    try:
        dt = datetime.fromisoformat(dt_str)
        return dt.strftime("%m/%d %H:%M")
    except (ValueError, TypeError):
        return ""


def sort_notes(notes):
    notes.sort(key=lambda n: n.get("updated", ""), reverse=True)


def copy_to_clipboard(text):
    try:
        proc = subprocess.Popen(["pbcopy"], stdin=subprocess.PIPE)
        proc.communicate(text.encode("utf-8"))
    except FileNotFoundError:
        pass


def claude_generate(prompt, existing_body=""):
    """Call claude CLI to generate/augment note content in markdown."""
    if existing_body:
        system_prompt = (
            "あなたはmarkdownノートのライターです。\n"
            "ユーザーから既存ノートの本文と修正指示を受け取ります。\n"
            "【厳守ルール】\n"
            "- 出力はmarkdown形式のノート本文のみ\n"
            "- 「作成しました」「以下の通りです」等の前置き・後書き・説明文は絶対に含めない\n"
            "- コードフェンスで全体を囲まない\n"
            "- 最初の文字からノート本文を開始すること"
        )
        user_msg = (
            f"<existing_note>\n{existing_body}\n</existing_note>\n\n"
            f"<instruction>\n{prompt}\n</instruction>"
        )
    else:
        system_prompt = (
            "あなたはmarkdownノートのライターです。\n"
            "ユーザーの指示に従ってmarkdownノートを作成してください。\n"
            "【厳守ルール】\n"
            "- 出力はmarkdown形式のノート本文のみ\n"
            "- 「作成しました」「以下の通りです」等の前置き・後書き・説明文は絶対に含めない\n"
            "- コードフェンスで全体を囲まない\n"
            "- 最初の文字からノート本文を開始すること"
        )
        user_msg = prompt

    env = os.environ.copy()
    env.pop("CLAUDECODE", None)
    try:
        proc = subprocess.run(
            ["claude", "-p", "--output-format", "text",
             "--system-prompt", system_prompt, user_msg],
            capture_output=True, text=True, timeout=120, env=env,
        )
        if proc.returncode == 0 and proc.stdout.strip():
            return proc.stdout.strip()
    except (FileNotFoundError, subprocess.TimeoutExpired):
        pass
    return None


# ── Text input ──────────────────────────────────────────────────


def textbox_input(stdscr, y, x, width, prompt="", initial=""):
    curses.curs_set(1)
    h, w = stdscr.getmaxyx()
    prompt_w = str_width(prompt)
    safe_addstr(stdscr, y, x, prompt, w - x)
    input_x = x + prompt_w
    max_cols = min(width - prompt_w - 1, w - input_x - 1)

    buf = list(initial)
    pos = len(buf)
    scroll = 0

    while True:
        visible = ""
        vis_w = 0
        cursor_col = 0

        for i in range(scroll, len(buf)):
            cw = char_width(buf[i])
            if vis_w + cw > max_cols:
                break
            visible += buf[i]
            vis_w += cw
            if i < pos:
                cursor_col += cw

        if pos == scroll:
            cursor_col = 0
        if pos < scroll:
            scroll = pos
            continue
        if cursor_col >= max_cols:
            scroll += 1
            continue

        pad = " " * max(0, max_cols - vis_w)
        try:
            stdscr.addstr(y, input_x, visible + pad)
            stdscr.move(y, input_x + cursor_col)
        except curses.error:
            pass
        stdscr.refresh()

        ch = stdscr.get_wch()

        if ch == "\n" or ch == curses.KEY_ENTER:
            break
        elif ch == "\x1b":
            curses.curs_set(0)
            return None
        elif ch in ("\x7f", "\b", curses.KEY_BACKSPACE):
            if pos > 0:
                buf.pop(pos - 1)
                pos -= 1
                if scroll > 0:
                    scroll = max(0, scroll - 1)
        elif ch == curses.KEY_DC:
            if pos < len(buf):
                buf.pop(pos)
        elif ch == curses.KEY_LEFT:
            if pos > 0:
                pos -= 1
        elif ch == curses.KEY_RIGHT:
            if pos < len(buf):
                pos += 1
        elif ch == curses.KEY_HOME or ch == "\x01":
            pos = 0
            scroll = 0
        elif ch == curses.KEY_END or ch == "\x05":
            pos = len(buf)
        elif ch == "\x15":  # Ctrl-U
            buf = buf[pos:]
            pos = 0
            scroll = 0
        elif ch == "\x0b":  # Ctrl-K
            buf = buf[:pos]
        elif isinstance(ch, str) and len(ch) == 1 and ch >= " ":
            buf.insert(pos, ch)
            pos += 1

    curses.curs_set(0)
    return "".join(buf)


# ── Body editor (in-pane) ──────────────────────────────────────


def body_editor(stdscr, title, body_text, area_top, area_left, area_w, area_h):
    curses.curs_set(1)

    lines = body_text.split("\n") if body_text else [""]
    cy, cx = 0, 0
    scroll = 0
    visible_lines = area_h

    while True:
        for i in range(visible_lines):
            li = scroll + i
            row = area_top + i
            try:
                stdscr.move(row, area_left)
                stdscr.clrtoeol()
            except curses.error:
                pass
            if li < len(lines):
                safe_addstr(stdscr, row, area_left, lines[li], area_w)

        h, w = stdscr.getmaxyx()
        footer = " Alt+Enter:Save  ESC:Cancel"
        try:
            stdscr.move(h - 1, 0)
            stdscr.clrtoeol()
        except curses.error:
            pass
        safe_addstr(stdscr, h - 1, 0, footer, w - 1)

        if cy - scroll >= visible_lines:
            scroll = cy - visible_lines + 1
        if cy < scroll:
            scroll = cy

        screen_y = area_top + cy - scroll
        screen_x = area_left + str_width(lines[cy][:cx]) if cy < len(lines) else area_left
        screen_x = min(screen_x, area_left + area_w - 1)
        try:
            stdscr.move(screen_y, screen_x)
        except curses.error:
            pass
        stdscr.refresh()

        ch = stdscr.get_wch()

        if ch == "\x1b":
            stdscr.nodelay(True)
            next_ch = None
            try:
                next_ch = stdscr.get_wch()
            except curses.error:
                pass
            stdscr.nodelay(False)
            if next_ch == "\n" or next_ch == "\r":
                curses.curs_set(0)
                return "\n".join(lines)
            else:
                curses.curs_set(0)
                return None
        elif ch == "\n" or ch == curses.KEY_ENTER:
            rest = lines[cy][cx:]
            lines[cy] = lines[cy][:cx]
            lines.insert(cy + 1, rest)
            cy += 1
            cx = 0
        elif ch in ("\x7f", "\b", curses.KEY_BACKSPACE):
            if cx > 0:
                lines[cy] = lines[cy][:cx - 1] + lines[cy][cx:]
                cx -= 1
            elif cy > 0:
                cx = len(lines[cy - 1])
                lines[cy - 1] += lines[cy]
                lines.pop(cy)
                cy -= 1
        elif ch == curses.KEY_DC:
            if cx < len(lines[cy]):
                lines[cy] = lines[cy][:cx] + lines[cy][cx + 1:]
            elif cy < len(lines) - 1:
                lines[cy] += lines[cy + 1]
                lines.pop(cy + 1)
        elif ch == curses.KEY_UP:
            if cy > 0:
                cy -= 1
                cx = min(cx, len(lines[cy]))
        elif ch == curses.KEY_DOWN:
            if cy < len(lines) - 1:
                cy += 1
                cx = min(cx, len(lines[cy]))
        elif ch == curses.KEY_LEFT:
            if cx > 0:
                cx -= 1
            elif cy > 0:
                cy -= 1
                cx = len(lines[cy])
        elif ch == curses.KEY_RIGHT:
            if cx < len(lines[cy]):
                cx += 1
            elif cy < len(lines) - 1:
                cy += 1
                cx = 0
        elif ch == curses.KEY_HOME or ch == "\x01":
            cx = 0
        elif ch == curses.KEY_END or ch == "\x05":
            cx = len(lines[cy])
        elif isinstance(ch, str) and len(ch) == 1 and ch >= " ":
            lines[cy] = lines[cy][:cx] + ch + lines[cy][cx:]
            cx += 1


# ── Template editor (fullscreen) ───────────────────────────────


def template_editor(stdscr, title, body_text):
    curses.curs_set(1)
    h, w = stdscr.getmaxyx()

    lines = body_text.split("\n") if body_text else [""]
    cy, cx = 0, 0
    scroll = 0

    while True:
        stdscr.erase()
        header = f" {ICON_TMPL} Template: {title} "
        stdscr.attron(curses.A_BOLD)
        safe_addstr(stdscr, 0, 0, header, w - 1)
        stdscr.attroff(curses.A_BOLD)
        safe_addstr(stdscr, 1, 0, "─" * (w - 1), w - 1)

        edit_top = 2
        visible_lines = h - edit_top - 2

        if cy - scroll >= visible_lines:
            scroll = cy - visible_lines + 1
        if cy < scroll:
            scroll = cy

        for i in range(visible_lines):
            li = scroll + i
            row = edit_top + i
            if li < len(lines):
                safe_addstr(stdscr, row, 0, lines[li], w - 1)

        footer = " Alt+Enter:Save  ESC:Cancel "
        safe_addstr(stdscr, h - 1, 0, footer, w - 1, curses.A_REVERSE)

        screen_y = edit_top + cy - scroll
        screen_x = str_width(lines[cy][:cx]) if cy < len(lines) else 0
        screen_x = min(screen_x, w - 1)
        try:
            stdscr.move(screen_y, screen_x)
        except curses.error:
            pass
        stdscr.refresh()

        ch = stdscr.get_wch()

        if ch == "\x1b":
            stdscr.nodelay(True)
            next_ch = None
            try:
                next_ch = stdscr.get_wch()
            except curses.error:
                pass
            stdscr.nodelay(False)
            if next_ch == "\n" or next_ch == "\r":
                curses.curs_set(0)
                return "\n".join(lines)
            else:
                curses.curs_set(0)
                return None
        elif ch == "\n" or ch == curses.KEY_ENTER:
            rest = lines[cy][cx:]
            lines[cy] = lines[cy][:cx]
            lines.insert(cy + 1, rest)
            cy += 1
            cx = 0
        elif ch in ("\x7f", "\b", curses.KEY_BACKSPACE):
            if cx > 0:
                lines[cy] = lines[cy][:cx - 1] + lines[cy][cx:]
                cx -= 1
            elif cy > 0:
                cx = len(lines[cy - 1])
                lines[cy - 1] += lines[cy]
                lines.pop(cy)
                cy -= 1
        elif ch == curses.KEY_DC:
            if cx < len(lines[cy]):
                lines[cy] = lines[cy][:cx] + lines[cy][cx + 1:]
            elif cy < len(lines) - 1:
                lines[cy] += lines[cy + 1]
                lines.pop(cy + 1)
        elif ch == curses.KEY_UP:
            if cy > 0:
                cy -= 1
                cx = min(cx, len(lines[cy]))
        elif ch == curses.KEY_DOWN:
            if cy < len(lines) - 1:
                cy += 1
                cx = min(cx, len(lines[cy]))
        elif ch == curses.KEY_LEFT:
            if cx > 0:
                cx -= 1
            elif cy > 0:
                cy -= 1
                cx = len(lines[cy])
        elif ch == curses.KEY_RIGHT:
            if cx < len(lines[cy]):
                cx += 1
            elif cy < len(lines) - 1:
                cy += 1
                cx = 0
        elif ch == curses.KEY_HOME or ch == "\x01":
            cx = 0
        elif ch == curses.KEY_END or ch == "\x05":
            cx = len(lines[cy])
        elif isinstance(ch, str) and len(ch) == 1 and ch >= " ":
            lines[cy] = lines[cy][:cx] + ch + lines[cy][cx:]
            cx += 1


# ── Template manager ────────────────────────────────────────────


def template_manager(stdscr):
    templates = load_templates()
    cursor = 0
    message = ""

    while True:
        stdscr.erase()
        h, w = stdscr.getmaxyx()

        header = f" {ICON_TMPL} Templates ({len(templates)})"
        stdscr.attron(curses.A_BOLD)
        safe_addstr(stdscr, 0, 0, header, w - 1)
        stdscr.attroff(curses.A_BOLD)

        sep = "─" * (w - 1)
        safe_addstr(stdscr, 1, 0, sep, w - 1)

        row = 2
        for i, tmpl in enumerate(templates):
            if row >= h - 2:
                break
            prefix = f" {ICON_CURSOR} " if i == cursor else "   "
            line = f"{prefix}{i + 1}.  {tmpl['title']}"
            attr = curses.A_REVERSE if i == cursor else 0
            pad_needed = w - 1 - str_width(line)
            if pad_needed > 0:
                line += " " * pad_needed
            safe_addstr(stdscr, row, 0, line, w - 1, attr)
            row += 1

        if h - 2 >= 0:
            safe_addstr(stdscr, h - 2, 0, sep, w - 1)

        if message:
            footer = f" {message}"
        else:
            footer = " a:Add  x:Del  e:Edit  ESC:Back"
        safe_addstr(stdscr, h - 1, 0, footer, w - 1)

        stdscr.refresh()
        message = ""

        ch = stdscr.getch()

        if ch == 27:  # ESC
            return
        elif ch == ord("j") or ch == curses.KEY_DOWN:
            if templates and cursor < len(templates) - 1:
                cursor += 1
        elif ch == ord("k") or ch == curses.KEY_UP:
            if cursor > 0:
                cursor -= 1
        elif ch == ord("g"):
            cursor = 0
        elif ch == ord("G"):
            if templates:
                cursor = len(templates) - 1
        elif ch == ord("a"):
            title = textbox_input(stdscr, h - 1, 0, w, " Template name: ")
            if title and title.strip():
                body = template_editor(stdscr, title.strip(), "")
                if body is not None:
                    tmpl = {
                        "id": next_id(templates),
                        "title": title.strip(),
                        "body": body,
                    }
                    save_template(tmpl)
                    templates.append(tmpl)
                    cursor = len(templates) - 1
                    message = "Template added"
        elif ch == ord("x"):
            if templates:
                name = templates[cursor]["title"]
                prompt = f" Delete '{name}'? (y/n) "
                pad = " " * max(0, w - 1 - str_width(prompt))
                safe_addstr(stdscr, h - 1, 0, prompt + pad, w - 1, curses.A_REVERSE)
                stdscr.refresh()
                confirm = stdscr.getch()
                if confirm == ord("y"):
                    delete_template(templates[cursor])
                    templates.pop(cursor)
                    if cursor >= len(templates) and cursor > 0:
                        cursor -= 1
                    message = "Deleted"
                else:
                    message = "Cancelled"
        elif ch == ord("e") or ch == ord("\n") or ch == curses.KEY_ENTER:
            if templates:
                tmpl = templates[cursor]
                body = template_editor(stdscr, tmpl["title"], tmpl["body"])
                if body is not None:
                    tmpl["body"] = body
                    save_template(tmpl)
                    message = "Template saved"


# ── Main screen drawing ─────────────────────────────────────────


def draw_main(stdscr, notes, cursor, left_w, focus, message, editing):
    h, w = stdscr.getmaxyx()
    stdscr.erase()

    right_x = left_w + 1
    right_w = w - right_x

    # Left pane header
    lh = f" {ICON_NOTE} Notes ({len(notes)})"
    stdscr.attron(curses.A_BOLD)
    safe_addstr(stdscr, 0, 0, lh, left_w)
    stdscr.attroff(curses.A_BOLD)

    # Right pane header
    if notes and 0 <= cursor < len(notes):
        note = notes[cursor]
        rh_title = note["title"]
        rh_date = format_date(note.get("updated", ""))
        rh_left = f" {rh_title}"
        avail = right_w - str_width(rh_date) - 2
        rh_left = truncate_to_width(rh_left, avail)
        gap = right_w - str_width(rh_left) - str_width(rh_date)
        rh = rh_left + " " * max(1, gap) + rh_date
    else:
        rh = ""
    stdscr.attron(curses.A_BOLD)
    safe_addstr(stdscr, 0, right_x, rh, right_w)
    stdscr.attroff(curses.A_BOLD)

    # Separator line row 1
    for col in range(left_w):
        safe_addstr(stdscr, 1, col, "─", 1)
    safe_addstr(stdscr, 1, left_w, "┼", 1)
    for col in range(right_x, w - 1):
        safe_addstr(stdscr, 1, col, "─", 1)

    # Vertical separator
    safe_addstr(stdscr, 0, left_w, "│", 1)
    for row in range(2, h - 2):
        safe_addstr(stdscr, row, left_w, "│", 1)

    # Left pane: note list
    list_top = 2
    list_h = h - 4
    for i, note in enumerate(notes):
        if i >= list_h:
            break
        row = list_top + i
        prefix = f" {ICON_CURSOR} " if i == cursor else "   "
        line = f"{prefix}{i + 1}.  {note['title']}"
        attr = 0
        if i == cursor:
            attr = curses.A_REVERSE if focus == "left" else curses.A_BOLD
        pad_needed = left_w - str_width(line)
        if pad_needed > 0:
            line += " " * pad_needed
        safe_addstr(stdscr, row, 0, line, left_w, attr)

    # Right pane: body preview
    if notes and 0 <= cursor < len(notes):
        body = notes[cursor].get("body", "")
        body_lines = body.split("\n") if body else [""]
        body_top = 2
        body_h = h - 4
        return body_lines, body_top, body_h, right_x, right_w
    else:
        return [], 2, h - 4, right_x, right_w


# ── Main loop ────────────────────────────────────────────────────


def main(stdscr):
    curses.curs_set(0)
    curses.use_default_colors()
    stdscr.keypad(True)

    notes = load_notes()
    sort_notes(notes)
    cursor = 0
    message = ""
    focus = "left"
    right_scroll = 0

    while True:
        h, w = stdscr.getmaxyx()
        left_w = max(20, w * 30 // 100)

        body_lines, body_top, body_h, right_x, right_w = draw_main(
            stdscr, notes, cursor, left_w, focus, message, False
        )

        # Draw right pane body with scroll
        for i in range(body_h):
            li = right_scroll + i
            row = body_top + i
            if li < len(body_lines):
                safe_addstr(stdscr, row, right_x + 1, body_lines[li], right_w - 2)

        # Bottom separator
        sep = "─" * (w - 1)
        if h - 2 >= 0:
            safe_addstr(stdscr, h - 2, 0, sep, w - 1)

        # Footer
        if message:
            footer = f" {message}"
        else:
            if focus == "left":
                footer = " a:Add  x:Del  e:Rename  Enter:Edit  y:Copy  c:AI  Tab:Switch  t:Tmpl  q:Quit"
            else:
                footer = " j/k:Scroll  g/G:Top/Bottom  y:Copy  Tab:Switch  q:Quit"
        safe_addstr(stdscr, h - 1, 0, footer, w - 1)

        # Focus indicator
        if focus == "right":
            for row in range(2, h - 2):
                safe_addstr(stdscr, row, left_w, "│", 1, curses.A_BOLD)

        stdscr.refresh()
        message = ""

        ch = stdscr.getch()

        if ch == ord("q"):
            break
        elif ch == ord("\t") or ch == 9:
            if focus == "left":
                focus = "right"
                right_scroll = 0
            else:
                focus = "left"
        elif focus == "left":
            if ch == ord("j") or ch == curses.KEY_DOWN:
                if notes and cursor < len(notes) - 1:
                    cursor += 1
                    right_scroll = 0
            elif ch == ord("k") or ch == curses.KEY_UP:
                if cursor > 0:
                    cursor -= 1
                    right_scroll = 0
            elif ch == ord("g"):
                cursor = 0
                right_scroll = 0
            elif ch == ord("G"):
                if notes:
                    cursor = len(notes) - 1
                    right_scroll = 0
            elif ch == ord("a"):
                templates = load_templates()
                if templates:
                    prompt = " [1] Blank"
                    for i, tmpl in enumerate(templates):
                        prompt += f"  [{i + 2}] {tmpl['title']}"
                    prompt += "  "
                    safe_addstr(stdscr, h - 1, 0, " " * (w - 1), w - 1)
                    safe_addstr(stdscr, h - 1, 0, prompt, w - 1)
                    stdscr.refresh()
                    sel = stdscr.getch()
                    if sel == 27:
                        continue
                    sel_idx = sel - ord("1") if ord("1") <= sel <= ord("9") else -1
                    if sel_idx == 0:
                        template_body = ""
                    elif 1 <= sel_idx <= len(templates):
                        template_body = templates[sel_idx - 1]["body"]
                    else:
                        continue
                else:
                    template_body = ""

                title = textbox_input(stdscr, h - 1, 0, w, " Title: ")
                if title and title.strip():
                    ts = now_str()
                    note = {
                        "id": next_id(notes),
                        "title": title.strip(),
                        "body": template_body,
                        "created": ts,
                        "updated": ts,
                    }
                    save_note(note)
                    notes.append(note)
                    sort_notes(notes)
                    cursor = 0
                    message = "Added"
            elif ch == ord("x"):
                if notes:
                    name = notes[cursor]["title"]
                    prompt = f" Delete '{name}'? (y/n) "
                    pad = " " * max(0, w - 1 - str_width(prompt))
                    safe_addstr(stdscr, h - 1, 0, prompt + pad, w - 1, curses.A_REVERSE)
                    stdscr.refresh()
                    confirm = stdscr.getch()
                    if confirm == ord("y"):
                        delete_note(notes[cursor])
                        notes.pop(cursor)
                        if cursor >= len(notes) and cursor > 0:
                            cursor -= 1
                        message = "Deleted"
                    else:
                        message = "Cancelled"
            elif ch == ord("e"):
                if notes:
                    old = notes[cursor]["title"]
                    new_title = textbox_input(stdscr, h - 1, 0, w, " Rename: ", old)
                    if new_title is not None and new_title.strip():
                        notes[cursor]["title"] = new_title.strip()
                        save_note(notes[cursor])
                        message = "Renamed"
            elif ch == ord("\n") or ch == curses.KEY_ENTER:
                if notes:
                    note = notes[cursor]
                    draw_main(stdscr, notes, cursor, left_w, "left", "", True)
                    sep = "─" * (w - 1)
                    if h - 2 >= 0:
                        safe_addstr(stdscr, h - 2, 0, sep, w - 1)
                    for row in range(2, h - 2):
                        safe_addstr(stdscr, row, left_w, "│", 1)
                    stdscr.refresh()

                    area_top = 2
                    area_h = h - 4
                    result = body_editor(
                        stdscr, note["title"], note.get("body", ""),
                        area_top, right_x + 1, right_w - 2, area_h
                    )
                    if result is not None:
                        note["body"] = result
                        note["updated"] = now_str()
                        save_note(note)
                        sort_notes(notes)
                        for i, n in enumerate(notes):
                            if n["id"] == note["id"]:
                                cursor = i
                                break
                        message = "Saved"
                    right_scroll = 0
            elif ch == ord("y"):
                if notes:
                    copy_to_clipboard(notes[cursor].get("body", ""))
                    message = "Copied to clipboard"
            elif ch == ord("c"):
                if notes:
                    safe_addstr(stdscr, h - 1, 0, " " * (w - 1), w - 1)
                    safe_addstr(stdscr, h - 1, 0, " [1] New note  [2] Augment current ", w - 1)
                    stdscr.refresh()
                    mode_ch = stdscr.getch()
                else:
                    mode_ch = ord("1")

                if mode_ch == ord("1"):
                    title = textbox_input(stdscr, h - 1, 0, w, " Title: ")
                    if title and title.strip():
                        prompt = textbox_input(stdscr, h - 1, 0, w, " Prompt: ")
                        if prompt and prompt.strip():
                            safe_addstr(stdscr, h - 1, 0, " " * (w - 1), w - 1)
                            safe_addstr(stdscr, h - 1, 0, " Generating...", w - 1)
                            stdscr.refresh()
                            result = claude_generate(prompt.strip())
                            if result:
                                ts = now_str()
                                note = {
                                    "id": next_id(notes),
                                    "title": title.strip(),
                                    "body": result,
                                    "created": ts,
                                    "updated": ts,
                                }
                                save_note(note)
                                notes.append(note)
                                sort_notes(notes)
                                cursor = 0
                                message = "Generated"
                            else:
                                message = "Generation failed"
                elif mode_ch == ord("2") and notes:
                    prompt = textbox_input(stdscr, h - 1, 0, w, " Prompt: ")
                    if prompt and prompt.strip():
                        safe_addstr(stdscr, h - 1, 0, " " * (w - 1), w - 1)
                        safe_addstr(stdscr, h - 1, 0, " Generating...", w - 1)
                        stdscr.refresh()
                        note = notes[cursor]
                        result = claude_generate(prompt.strip(), note.get("body", ""))
                        if result:
                            note["body"] = result
                            note["updated"] = now_str()
                            save_note(note)
                            sort_notes(notes)
                            for i, n in enumerate(notes):
                                if n["id"] == note["id"]:
                                    cursor = i
                                    break
                            message = "Updated by AI"
                        else:
                            message = "Generation failed"
            elif ch == ord("t"):
                template_manager(stdscr)
        elif focus == "right":
            if ch == ord("j") or ch == curses.KEY_DOWN:
                if right_scroll < max(0, len(body_lines) - body_h):
                    right_scroll += 1
            elif ch == ord("k") or ch == curses.KEY_UP:
                if right_scroll > 0:
                    right_scroll -= 1
            elif ch == ord("g"):
                right_scroll = 0
            elif ch == ord("G"):
                right_scroll = max(0, len(body_lines) - body_h)
            elif ch == ord("y"):
                if notes:
                    copy_to_clipboard(notes[cursor].get("body", ""))
                    message = "Copied to clipboard"


if __name__ == "__main__":
    curses.wrapper(main)
