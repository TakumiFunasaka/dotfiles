#!/usr/bin/env python3
"""h - Health reminder TUI (matched with focus app reminders)"""

import curses
import json
import os
import time
import unicodedata
from datetime import datetime

STATE_FILE = os.path.expanduser("~/.health_reminders.json")

# Reminder types (matching focus app)
REMINDER_TYPES = [
    {"key": "water",       "icon": "\uf043",  "label": "水を飲む",       "title": "水分補給の時間です",       "msg": "コップ1杯の水を飲みましょう"},
    {"key": "medicine",    "icon": "\uf0f1",  "label": "薬を飲む",       "title": "お薬の時間です",           "msg": "お薬を飲みましょう"},
    {"key": "supplement",  "icon": "\uf469",  "label": "サプリを飲む",   "title": "サプリメントの時間です",   "msg": "サプリメントを飲みましょう"},
    {"key": "exercise",    "icon": "\uf44b",  "label": "運動をする",     "title": "運動の時間です",           "msg": "運動で体を動かしましょう"},
    {"key": "temperature", "icon": "\uf2c9",  "label": "体温を測る",     "title": "体温測定の時間です",       "msg": "体温を測りましょう"},
    {"key": "stand",       "icon": "\uf183",  "label": "立ち上がる",     "title": "立ち上がりましょう",       "msg": "少し体を動かして、血行を良くしましょう"},
    {"key": "rest",        "icon": "\uf070",  "label": "目を休める",     "title": "目を休めましょう",         "msg": "20秒間、遠くを見て目を休ませましょう"},
]

ICON_CHECK = "\uf00c"
ICON_CURSOR = "\uf054"
ICON_HEALTH = "\uf21e"
ICON_GEAR = "\uf013"
ICON_ON = "\uf205"
ICON_OFF = "\uf204"
SNOOZE_MINS = 30


# ── Display utilities ──────────────────────────────────────────


def char_width(ch):
    ea = unicodedata.east_asian_width(ch)
    return 2 if ea in ("F", "W") else 1


def str_width(s):
    return sum(char_width(c) for c in s)


def truncate_to_width(s, max_w):
    w = 0
    for i, c in enumerate(s):
        cw = char_width(c)
        if w + cw > max_w:
            return s[:i]
        w += cw
    return s


def safe_addstr(win, y, x, text, max_w, attr=0):
    truncated = truncate_to_width(text, max_w)
    try:
        win.addstr(y, x, truncated, attr)
    except curses.error:
        pass


def textbox_input(stdscr, y, x, width, prompt="", initial=""):
    """Inline text input."""
    curses.curs_set(1)
    h, w = stdscr.getmaxyx()
    prompt_w = str_width(prompt)
    safe_addstr(stdscr, y, x, prompt, w - x)
    input_x = x + prompt_w
    max_cols = min(width - prompt_w - 1, w - input_x - 1)

    buf = list(initial)
    pos = len(buf)

    while True:
        visible = "".join(buf)
        vis_w = str_width(visible)
        cursor_col = str_width("".join(buf[:pos]))

        pad = " " * max(0, max_cols - vis_w)
        try:
            stdscr.addstr(y, input_x, truncate_to_width(visible + pad, max_cols))
            stdscr.move(y, input_x + min(cursor_col, max_cols - 1))
        except curses.error:
            pass
        stdscr.refresh()

        ch = stdscr.get_wch()

        if ch == "\n" or ch == curses.KEY_ENTER:
            break
        elif ch == "\x1b":
            curses.curs_set(0)
            return None
        elif ch in ("\x7f", "\b", curses.KEY_BACKSPACE):
            if pos > 0:
                buf.pop(pos - 1)
                pos -= 1
        elif ch == curses.KEY_LEFT:
            if pos > 0:
                pos -= 1
        elif ch == curses.KEY_RIGHT:
            if pos < len(buf):
                pos += 1
        elif isinstance(ch, str) and len(ch) == 1 and ch >= " ":
            buf.insert(pos, ch)
            pos += 1

    curses.curs_set(0)
    return "".join(buf)


# ── State management ──────────────────────────────────────────


def default_reminders():
    return [
        {"type": "water",  "times": ["10:00", "12:00", "15:00", "17:00"], "enabled": True},
        {"type": "stand",  "times": ["11:00", "14:00", "16:00"], "enabled": True},
        {"type": "rest",   "times": ["10:30", "14:30", "16:30"], "enabled": True},
    ]


def load_state():
    today = datetime.now().strftime("%Y-%m-%d")
    if os.path.exists(STATE_FILE):
        with open(STATE_FILE, "r", encoding="utf-8") as f:
            state = json.load(f)
        if state.get("date") != today:
            state["date"] = today
            state["done"] = {}
            state["snoozed"] = {}
            save_state(state)
        return state
    state = {
        "date": today,
        "reminders": default_reminders(),
        "done": {},
        "snoozed": {},
    }
    save_state(state)
    return state


def save_state(state):
    with open(STATE_FILE, "w", encoding="utf-8") as f:
        json.dump(state, f, ensure_ascii=False, indent=2)


def get_type_info(key):
    for rt in REMINDER_TYPES:
        if rt["key"] == key:
            return rt
    return REMINDER_TYPES[0]


def build_timeline(state):
    timeline = []
    for rem in state.get("reminders", []):
        if not rem.get("enabled"):
            continue
        for t in rem.get("times", []):
            rkey = f"{rem['type']}_{t}"
            done = state.get("done", {}).get(rkey, False)
            snoozed = state.get("snoozed", {}).get(rkey, "")
            timeline.append((t, rem["type"], done, snoozed, rkey))
    timeline.sort(key=lambda x: x[0])
    return timeline


def check_alerts(timeline):
    now_str = datetime.now().strftime("%H:%M")
    alerts = []
    for t, type_key, done, snoozed, rkey in timeline:
        if done:
            continue
        if snoozed and now_str < snoozed:
            continue
        if t <= now_str:
            alerts.append((rkey, type_key))
    return alerts


def validate_time(s):
    """Return normalized HH:MM or None."""
    s = s.strip()
    if len(s) >= 3 and ":" in s:
        parts = s.split(":")
        if len(parts) == 2:
            try:
                hh, mm = int(parts[0]), int(parts[1])
                if 0 <= hh <= 23 and 0 <= mm <= 59:
                    return f"{hh:02d}:{mm:02d}"
            except ValueError:
                pass
    return None


# ── Settings screen ───────────────────────────────────────────


def settings_screen(stdscr, state):
    """Settings screen for managing reminder groups."""
    cursor = 0
    message = ""
    mode = "list"  # list, times

    while True:
        stdscr.erase()
        h, w = stdscr.getmaxyx()
        reminders = state.get("reminders", [])

        # ── Header ──
        header = f" {ICON_GEAR} Settings"
        stdscr.attron(curses.A_BOLD)
        safe_addstr(stdscr, 0, 0, header, w - 1)
        stdscr.attroff(curses.A_BOLD)
        safe_addstr(stdscr, 1, 0, "─" * (w - 1), w - 1)

        if mode == "list":
            # ── Reminder group list ──
            for i, rem in enumerate(reminders):
                row = 2 + i
                if row >= h - 2:
                    break
                info = get_type_info(rem["type"])
                enabled = rem.get("enabled", True)
                toggle = ICON_ON if enabled else ICON_OFF
                times_str = ", ".join(rem.get("times", []))
                prefix = f" {ICON_CURSOR} " if i == cursor else "   "
                line = f"{prefix}{toggle}  {info['icon']}  {info['label']}  ({times_str})"
                attr = curses.A_REVERSE if i == cursor else 0
                if not enabled:
                    attr |= curses.A_DIM
                safe_addstr(stdscr, row, 0, line, w - 1, attr)

            if not reminders:
                safe_addstr(stdscr, 2, 0, " No reminders configured", w - 1)

            # ── Available types hint ──
            used_types = {r["type"] for r in reminders}
            available = [rt for rt in REMINDER_TYPES if rt["key"] not in used_types]
            if available and 2 + len(reminders) + 1 < h - 2:
                hint_row = 2 + len(reminders) + 1
                safe_addstr(stdscr, hint_row, 0, "─" * (w - 1), w - 1)
                hint = " Add: " + ", ".join(f"{rt['icon']} {rt['label']}" for rt in available[:4])
                if len(available) > 4:
                    hint += " ..."
                safe_addstr(stdscr, hint_row + 1, 0, hint, w - 1, curses.A_DIM)

            # ── Footer ──
            safe_addstr(stdscr, h - 2, 0, "─" * (w - 1), w - 1)
            if message:
                footer = f" {message}"
            else:
                footer = " e:Toggle  a:Add  x:Del  t:Edit times  ESC:Back"
            safe_addstr(stdscr, h - 1, 0, footer, w - 1)

            stdscr.refresh()
            message = ""

            ch = stdscr.getch()

            if ch == 27:  # ESC
                return
            elif ch == ord("j") or ch == curses.KEY_DOWN:
                if reminders and cursor < len(reminders) - 1:
                    cursor += 1
            elif ch == ord("k") or ch == curses.KEY_UP:
                if cursor > 0:
                    cursor -= 1
            elif ch == ord("e"):
                if reminders:
                    reminders[cursor]["enabled"] = not reminders[cursor].get("enabled", True)
                    save_state(state)
                    status = "ON" if reminders[cursor]["enabled"] else "OFF"
                    message = f"Toggled {status}"
            elif ch == ord("a"):
                # Show type selection
                used = {r["type"] for r in reminders}
                avail = [rt for rt in REMINDER_TYPES if rt["key"] not in used]
                if not avail:
                    message = "All types already added"
                    continue

                safe_addstr(stdscr, h - 1, 0, " " * (w - 1), w - 1)
                sel_str = " Select: " + "  ".join(
                    f"[{i + 1}]{rt['icon']} {rt['label']}" for i, rt in enumerate(avail[:7])
                )
                safe_addstr(stdscr, h - 1, 0, sel_str, w - 1)
                stdscr.refresh()

                sel_ch = stdscr.getch()
                sel_idx = sel_ch - ord("1") if ord("1") <= sel_ch <= ord("9") else -1
                if 0 <= sel_idx < len(avail):
                    chosen = avail[sel_idx]
                    # Ask for first time
                    time_str = textbox_input(stdscr, h - 1, 0, w, f" Time for {chosen['label']} (HH:MM): ")
                    if time_str:
                        t = validate_time(time_str)
                        if t:
                            reminders.append({
                                "type": chosen["key"],
                                "times": [t],
                                "enabled": True,
                            })
                            cursor = len(reminders) - 1
                            save_state(state)
                            message = f"Added {chosen['label']} at {t}"
                        else:
                            message = "Invalid time format"
            elif ch == ord("x"):
                if reminders:
                    info = get_type_info(reminders[cursor]["type"])
                    prompt = f" Delete {info['label']}? (y/n) "
                    pad = " " * max(0, w - 1 - str_width(prompt))
                    safe_addstr(stdscr, h - 1, 0, prompt + pad, w - 1, curses.A_REVERSE)
                    stdscr.refresh()
                    confirm = stdscr.getch()
                    if confirm == ord("y"):
                        reminders.pop(cursor)
                        if cursor >= len(reminders) and cursor > 0:
                            cursor -= 1
                        save_state(state)
                        message = "Deleted"
                    else:
                        message = "Cancelled"
            elif ch == ord("t"):
                if reminders:
                    mode = "times"

        elif mode == "times":
            # ── Time editing for selected reminder ──
            rem = reminders[cursor]
            info = get_type_info(rem["type"])
            times = rem.get("times", [])

            sub_header = f" {info['icon']}  {info['label']} - Times"
            stdscr.attron(curses.A_BOLD)
            safe_addstr(stdscr, 2, 0, sub_header, w - 1)
            stdscr.attroff(curses.A_BOLD)
            safe_addstr(stdscr, 3, 0, "─" * (w - 1), w - 1)

            # Time cursor (reuse a local variable)
            if not hasattr(settings_screen, "_tcursor"):
                settings_screen._tcursor = 0
            tcursor = settings_screen._tcursor
            if tcursor >= len(times):
                tcursor = max(0, len(times) - 1)
                settings_screen._tcursor = tcursor

            for i, t in enumerate(times):
                row = 4 + i
                if row >= h - 2:
                    break
                prefix = f" {ICON_CURSOR} " if i == tcursor else "   "
                line = f"{prefix}{t}"
                attr = curses.A_REVERSE if i == tcursor else 0
                safe_addstr(stdscr, row, 0, line, w - 1, attr)

            if not times:
                safe_addstr(stdscr, 4, 0, " No times set", w - 1)

            safe_addstr(stdscr, h - 2, 0, "─" * (w - 1), w - 1)
            if message:
                footer = f" {message}"
            else:
                footer = " a:Add time  x:Del time  e:Edit time  ESC:Back"
            safe_addstr(stdscr, h - 1, 0, footer, w - 1)

            stdscr.refresh()
            message = ""

            ch = stdscr.getch()

            if ch == 27:  # ESC
                settings_screen._tcursor = 0
                mode = "list"
            elif ch == ord("j") or ch == curses.KEY_DOWN:
                if times and tcursor < len(times) - 1:
                    settings_screen._tcursor = tcursor + 1
            elif ch == ord("k") or ch == curses.KEY_UP:
                if tcursor > 0:
                    settings_screen._tcursor = tcursor - 1
            elif ch == ord("a"):
                time_str = textbox_input(stdscr, h - 1, 0, w, " Add time (HH:MM): ")
                if time_str:
                    t = validate_time(time_str)
                    if t:
                        times.append(t)
                        times.sort()
                        rem["times"] = times
                        save_state(state)
                        message = f"Added {t}"
                    else:
                        message = "Invalid time format"
            elif ch == ord("x"):
                if times:
                    removed = times.pop(tcursor)
                    if tcursor >= len(times) and tcursor > 0:
                        settings_screen._tcursor = tcursor - 1
                    rem["times"] = times
                    save_state(state)
                    message = f"Removed {removed}"
            elif ch == ord("e"):
                if times:
                    old = times[tcursor]
                    new_str = textbox_input(stdscr, h - 1, 0, w, " Edit time (HH:MM): ", old)
                    if new_str:
                        t = validate_time(new_str)
                        if t:
                            times[tcursor] = t
                            times.sort()
                            rem["times"] = times
                            save_state(state)
                            message = f"Changed to {t}"
                        else:
                            message = "Invalid time format"


# ── Main screen ───────────────────────────────────────────────


def main(stdscr):
    curses.curs_set(0)
    curses.use_default_colors()
    stdscr.keypad(True)
    curses.halfdelay(10)  # 100ms

    state = load_state()
    cursor = 0
    message = ""
    last_beep = 0

    while True:
        now = time.time()
        stdscr.erase()
        h, w = stdscr.getmaxyx()

        timeline = build_timeline(state)
        alerts = check_alerts(timeline)

        # Beep for alerts (once per minute)
        if alerts and now - last_beep > 60:
            curses.beep()
            print("\a", end="", flush=True)
            last_beep = now

        # ── Header ──
        now_str = datetime.now().strftime("%H:%M")
        done_count = sum(1 for _, _, d, _, _ in timeline if d)
        total = len(timeline)
        left = f" {ICON_HEALTH} Health  {now_str}"
        right = f" {ICON_CHECK} {done_count}/{total}"
        gap = w - 1 - str_width(left) - str_width(right)
        header = left + " " * max(1, gap) + right
        stdscr.attron(curses.A_BOLD)
        safe_addstr(stdscr, 0, 0, header, w - 1)
        stdscr.attroff(curses.A_BOLD)

        # ── Separator ──
        if h > 1:
            safe_addstr(stdscr, 1, 0, "─" * (w - 1), w - 1)

        # ── Alert banner ──
        banner_row = 2
        if alerts:
            rkey, type_key = alerts[0]
            info = get_type_info(type_key)
            banner = f" {info['icon']}  {info['title']}"
            safe_addstr(stdscr, banner_row, 0, banner, w - 1, curses.A_BOLD)
            safe_addstr(stdscr, banner_row + 1, 0, f"    {info['msg']}", w - 1)
            safe_addstr(stdscr, banner_row + 2, 0, "─" * (w - 1), w - 1)
            list_top = banner_row + 3
        else:
            list_top = banner_row

        # ── Timeline ──
        list_h = h - list_top - 2
        if cursor >= len(timeline):
            cursor = max(0, len(timeline) - 1)

        for i, (t, type_key, done, snoozed, rkey) in enumerate(timeline):
            row = list_top + i
            if row >= h - 2:
                break
            info = get_type_info(type_key)
            prefix = f" {ICON_CURSOR} " if i == cursor else "   "

            if done:
                status = f"{ICON_CHECK} "
            elif snoozed:
                status = f"~{snoozed} "
            else:
                status = "  "

            line = f"{prefix}{t}  {info['icon']}  {status}{info['label']}"
            attr = 0
            if i == cursor:
                attr = curses.A_REVERSE
            if done:
                attr |= curses.A_DIM
            safe_addstr(stdscr, row, 0, line, w - 1, attr)

        if not timeline:
            safe_addstr(stdscr, list_top, 0, " No reminders set (s to configure)", w - 1)

        # ── Bottom separator ──
        if h - 2 >= 0:
            safe_addstr(stdscr, h - 2, 0, "─" * (w - 1), w - 1)

        # ── Footer ──
        if message:
            footer = f" {message}"
        else:
            footer = " d:Done  z:Snooze(30m)  u:Undo  s:Settings  q:Quit"
        safe_addstr(stdscr, h - 1, 0, footer, w - 1)

        stdscr.refresh()
        message = ""

        try:
            ch = stdscr.getch()
        except curses.error:
            continue

        if ch == -1:
            continue
        elif ch == ord("q"):
            break
        elif ch == ord("j") or ch == curses.KEY_DOWN:
            if timeline and cursor < len(timeline) - 1:
                cursor += 1
        elif ch == ord("k") or ch == curses.KEY_UP:
            if cursor > 0:
                cursor -= 1
        elif ch == ord("d"):
            if timeline:
                rkey = timeline[cursor][4]
                state.setdefault("done", {})[rkey] = True
                if rkey in state.get("snoozed", {}):
                    del state["snoozed"][rkey]
                save_state(state)
                message = "Done!"
        elif ch == ord("z"):
            if timeline:
                rkey = timeline[cursor][4]
                now_dt = datetime.now()
                snooze_h = now_dt.hour + (now_dt.minute + SNOOZE_MINS) // 60
                snooze_m = (now_dt.minute + SNOOZE_MINS) % 60
                snooze_str = f"{snooze_h:02d}:{snooze_m:02d}"
                state.setdefault("snoozed", {})[rkey] = snooze_str
                save_state(state)
                message = f"Snoozed until {snooze_str}"
        elif ch == ord("u"):
            if timeline:
                rkey = timeline[cursor][4]
                if rkey in state.get("done", {}):
                    del state["done"][rkey]
                if rkey in state.get("snoozed", {}):
                    del state["snoozed"][rkey]
                save_state(state)
                message = "Reset"
        elif ch == ord("s"):
            settings_screen(stdscr, state)
            state = load_state()  # reload after settings change
            cursor = 0
        elif ch == ord("g"):
            cursor = 0
        elif ch == ord("G"):
            if timeline:
                cursor = len(timeline) - 1


if __name__ == "__main__":
    curses.wrapper(main)
